<div><p>Those Java list iterators are a bit weird, with the “you can't call remove unless you previously called next or previous” rule. And that's a Java thing. In the rest of the known universe (for example, in C++), one can call remove as often as one likes.</p>
  <p>Those iterators are much better. They follow the advice of Section 8.2.3 “Separating Accessors and Mutators” of your textbook. They separate movement from lookup. The <code>next</code> method moves the iterator and returns nothing. The <code>get</code> method yields what's at the iterator. The <code>remove</code> method removes what's at the iterator, causing it to point to the next element. And sure, then you can call it again, and it removes that element. The <code>add</code> method adds before the iterator (just like with Java iterators). The <code>atEnd</code> method states if the iterator is already at the end of the list (in which case <code>get/remove/next</code> should throw a <code>NoSuchElementException</code>).</p>
  <p>It's simple. There is just one catch. It only works with doubly-linked lists. Not a problem in 2015. Or 1995. So, go ahead and implement that.</p>
  <p>Tip: This is <em>much</em> simpler than the complex implementation of the iterator in Worked Example 16.1. Don't even try to start with that. Instead, simply set <code>position</code> to the current position of the iterator. It can point to any of the elements of the list, or it could be <code>null</code>, in which case it points past the end.</p>
  <p>For simplicity, we omit the <code>set</code>, <code>previous</code>, and <code>hasPrevious</code> methods.</p>
  <p>For the draft, just implement <code>next</code>, <code>atEnd</code>, and <code>get</code>. You don't need to know anything about doubly-linked lists to do that.</p>
</div>
